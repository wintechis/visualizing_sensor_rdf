import { ChangeDetectionStrategy, Component, ContentChildren, EventEmitter, Input, Output, ViewEncapsulation } from '@angular/core';
import { coerceNumberProperty } from './coercion/number-property';
import { KtdGridItemComponent } from './grid-item/grid-item.component';
import { combineLatest, merge, NEVER, Observable, of } from 'rxjs';
import { exhaustMap, map, startWith, switchMap, takeUntil } from 'rxjs/operators';
import { ktdGetGridItemRowHeight, ktdGridItemDragging, ktdGridItemLayoutItemAreEqual, ktdGridItemResizing } from './utils/grid.utils';
import { compact } from './utils/react-grid-layout.utils';
import { GRID_ITEM_GET_RENDER_DATA_TOKEN } from './grid.definitions';
import { ktdMouseOrTouchEnd, ktdPointerClientX, ktdPointerClientY } from './utils/pointer.utils';
import { getMutableClientRect } from './utils/client-rect';
import { ktdGetScrollTotalRelativeDifference$, ktdScrollIfNearElementClientRect$ } from './utils/scroll';
import { coerceBooleanProperty } from './coercion/boolean-property';
import * as i0 from "@angular/core";
import * as i1 from "./grid.service";
function getDragResizeEventData(gridItem, layout) {
    return {
        layout,
        layoutItem: layout.find((item) => item.id === gridItem.id),
        gridItemRef: gridItem
    };
}
function layoutToRenderItems(config, width, height) {
    const { cols, rowHeight, layout, gap } = config;
    const rowHeightInPixels = rowHeight === 'fit' ? ktdGetGridItemRowHeight(layout, height, gap) : rowHeight;
    const widthExcludingGap = width - Math.max((gap * (cols - 1)), 0);
    const itemWidthPerColumn = (widthExcludingGap / cols);
    const renderItems = {};
    for (const item of layout) {
        renderItems[item.id] = {
            id: item.id,
            top: item.y * rowHeightInPixels + gap * item.y,
            left: item.x * itemWidthPerColumn + gap * item.x,
            width: item.w * itemWidthPerColumn + gap * Math.max(item.w - 1, 0),
            height: item.h * rowHeightInPixels + gap * Math.max(item.h - 1, 0),
        };
    }
    return renderItems;
}
function getGridHeight(layout, rowHeight, gap) {
    return layout.reduce((acc, cur) => Math.max(acc, (cur.y + cur.h) * rowHeight + Math.max(cur.y + cur.h - 1, 0) * gap), 0);
}
// eslint-disable-next-line @katoid/prefix-exported-code
export function parseRenderItemToPixels(renderItem) {
    return {
        id: renderItem.id,
        top: `${renderItem.top}px`,
        left: `${renderItem.left}px`,
        width: `${renderItem.width}px`,
        height: `${renderItem.height}px`
    };
}
// eslint-disable-next-line @katoid/prefix-exported-code
export function __gridItemGetRenderDataFactoryFunc(gridCmp) {
    return function (id) {
        return parseRenderItemToPixels(gridCmp.getItemRenderData(id));
    };
}
export function ktdGridItemGetRenderDataFactoryFunc(gridCmp) {
    // Workaround explained: https://github.com/ng-packagr/ng-packagr/issues/696#issuecomment-387114613
    const resultFunc = __gridItemGetRenderDataFactoryFunc(gridCmp);
    return resultFunc;
}
export class KtdGridComponent {
    constructor(gridService, elementRef, viewContainerRef, renderer, ngZone) {
        this.gridService = gridService;
        this.elementRef = elementRef;
        this.viewContainerRef = viewContainerRef;
        this.renderer = renderer;
        this.ngZone = ngZone;
        /** Emits when layout change */
        this.layoutUpdated = new EventEmitter();
        /** Emits when drag starts */
        this.dragStarted = new EventEmitter();
        /** Emits when resize starts */
        this.resizeStarted = new EventEmitter();
        /** Emits when drag ends */
        this.dragEnded = new EventEmitter();
        /** Emits when resize ends */
        this.resizeEnded = new EventEmitter();
        /** Emits when a grid item is being resized and its bounds have changed */
        this.gridItemResize = new EventEmitter();
        /**
         * Parent element that contains the scroll. If an string is provided it would search that element by id on the dom.
         * If no data provided or null autoscroll is not performed.
         */
        this.scrollableParent = null;
        this._compactOnPropsChange = true;
        this._preventCollision = false;
        this._scrollSpeed = 2;
        this._compactType = 'vertical';
        this._rowHeight = 100;
        this._cols = 6;
        this._gap = 0;
        this._height = null;
    }
    /** Whether or not to update the internal layout when some dependent property change. */
    get compactOnPropsChange() { return this._compactOnPropsChange; }
    set compactOnPropsChange(value) {
        this._compactOnPropsChange = coerceBooleanProperty(value);
    }
    /** If true, grid items won't change position when being dragged over. Handy when using no compaction */
    get preventCollision() { return this._preventCollision; }
    set preventCollision(value) {
        this._preventCollision = coerceBooleanProperty(value);
    }
    /** Number of CSS pixels that would be scrolled on each 'tick' when auto scroll is performed. */
    get scrollSpeed() { return this._scrollSpeed; }
    set scrollSpeed(value) {
        this._scrollSpeed = coerceNumberProperty(value, 2);
    }
    /** Type of compaction that will be applied to the layout (vertical, horizontal or free). Defaults to 'vertical' */
    get compactType() {
        return this._compactType;
    }
    set compactType(val) {
        this._compactType = val;
    }
    /**
     * Row height as number or as 'fit'.
     * If rowHeight is a number value, it means that each row would have those css pixels in height.
     * if rowHeight is 'fit', it means that rows will fit in the height available. If 'fit' value is set, a 'height' should be also provided.
     */
    get rowHeight() { return this._rowHeight; }
    set rowHeight(val) {
        this._rowHeight = val === 'fit' ? val : Math.max(1, Math.round(coerceNumberProperty(val)));
    }
    /** Number of columns  */
    get cols() { return this._cols; }
    set cols(val) {
        this._cols = Math.max(1, Math.round(coerceNumberProperty(val)));
    }
    /** Layout of the grid. Array of all the grid items with its 'id' and position on the grid. */
    get layout() { return this._layout; }
    set layout(layout) {
        /**
         * Enhancement:
         * Only set layout if it's reference has changed and use a boolean to track whenever recalculate the layout on ngOnChanges.
         *
         * Why:
         * The normal use of this lib is having the variable layout in the outer component or in a store, assigning it whenever it changes and
         * binded in the component with it's input [layout]. In this scenario, we would always calculate one unnecessary change on the layout when
         * it is re-binded on the input.
         */
        this._layout = layout;
    }
    /** Grid gap in css pixels */
    get gap() {
        return this._gap;
    }
    set gap(val) {
        this._gap = Math.max(coerceNumberProperty(val), 0);
    }
    /**
     * If height is a number, fixes the height of the grid to it, recommended when rowHeight = 'fit' is used.
     * If height is null, height will be automatically set according to its inner grid items.
     * Defaults to null.
     * */
    get height() {
        return this._height;
    }
    set height(val) {
        this._height = typeof val === 'number' ? Math.max(val, 0) : null;
    }
    get config() {
        return {
            cols: this.cols,
            rowHeight: this.rowHeight,
            height: this.height,
            layout: this.layout,
            preventCollision: this.preventCollision,
            gap: this.gap,
        };
    }
    ngOnChanges(changes) {
        if (this.rowHeight === 'fit' && this.height == null) {
            console.warn(`KtdGridComponent: The @Input() height should not be null when using rowHeight 'fit'`);
        }
        let needsCompactLayout = false;
        let needsRecalculateRenderData = false;
        // TODO: Does fist change need to be compacted by default?
        // Compact layout whenever some dependent prop changes.
        if (changes.compactType || changes.cols || changes.layout) {
            needsCompactLayout = true;
        }
        // Check if wee need to recalculate rendering data.
        if (needsCompactLayout || changes.rowHeight || changes.height || changes.gap) {
            needsRecalculateRenderData = true;
        }
        // Only compact layout if lib user has provided it. Lib users that want to save/store always the same layout  as it is represented (compacted)
        // can use KtdCompactGrid utility and pre-compact the layout. This is the recommended behaviour for always having a the same layout on this component
        // and the ones that uses it.
        if (needsCompactLayout && this.compactOnPropsChange) {
            this.compactLayout();
        }
        if (needsRecalculateRenderData) {
            this.calculateRenderData();
        }
    }
    ngAfterContentInit() {
        this.initSubscriptions();
    }
    ngAfterContentChecked() {
        this.render();
    }
    resize() {
        this.calculateRenderData();
        this.render();
    }
    ngOnDestroy() {
        this.subscriptions.forEach(sub => sub.unsubscribe());
    }
    compactLayout() {
        this.layout = compact(this.layout, this.compactType, this.cols);
    }
    getItemsRenderData() {
        return { ...this._gridItemsRenderData };
    }
    getItemRenderData(itemId) {
        return this._gridItemsRenderData[itemId];
    }
    calculateRenderData() {
        const clientRect = this.elementRef.nativeElement.getBoundingClientRect();
        this.gridCurrentHeight = this.height ?? (this.rowHeight === 'fit' ? clientRect.height : getGridHeight(this.layout, this.rowHeight, this.gap));
        this._gridItemsRenderData = layoutToRenderItems(this.config, clientRect.width, this.gridCurrentHeight);
    }
    render() {
        this.renderer.setStyle(this.elementRef.nativeElement, 'height', `${this.gridCurrentHeight}px`);
        this.updateGridItemsStyles();
    }
    updateGridItemsStyles() {
        this._gridItems.forEach(item => {
            const gridItemRenderData = this._gridItemsRenderData[item.id];
            if (gridItemRenderData == null) {
                console.error(`Couldn\'t find the specified grid item for the id: ${item.id}`);
            }
            else {
                item.setStyles(parseRenderItemToPixels(gridItemRenderData));
            }
        });
    }
    initSubscriptions() {
        this.subscriptions = [
            this._gridItems.changes.pipe(startWith(this._gridItems), switchMap((gridItems) => {
                return merge(...gridItems.map((gridItem) => gridItem.dragStart$.pipe(map((event) => ({ event, gridItem, type: 'drag' })))), ...gridItems.map((gridItem) => gridItem.resizeStart$.pipe(map((event) => ({ event, gridItem, type: 'resize' }))))).pipe(exhaustMap(({ event, gridItem, type }) => {
                    // Emit drag or resize start events. Ensure that is start event is inside the zone.
                    this.ngZone.run(() => (type === 'drag' ? this.dragStarted : this.resizeStarted).emit(getDragResizeEventData(gridItem, this.layout)));
                    // Perform drag sequence
                    return this.performDragSequence$(gridItem, event, type).pipe(map((layout) => ({ layout, gridItem, type })));
                }));
            })).subscribe(({ layout, gridItem, type }) => {
                this.layout = layout;
                // Calculate new rendering data given the new layout.
                this.calculateRenderData();
                // Emit drag or resize end events.
                (type === 'drag' ? this.dragEnded : this.resizeEnded).emit(getDragResizeEventData(gridItem, layout));
                // Notify that the layout has been updated.
                this.layoutUpdated.emit(layout);
            })
        ];
    }
    /**
     * Perform a general grid drag action, from start to end. A general grid drag action basically includes creating the placeholder element and adding
     * some class animations. calcNewStateFunc needs to be provided in order to calculate the new state of the layout.
     * @param gridItem that is been dragged
     * @param pointerDownEvent event (mousedown or touchdown) where the user initiated the drag
     * @param calcNewStateFunc function that return the new layout state and the drag element position
     */
    performDragSequence$(gridItem, pointerDownEvent, type) {
        return new Observable((observer) => {
            // Retrieve grid (parent) and gridItem (draggedElem) client rects.
            const gridElemClientRect = getMutableClientRect(this.elementRef.nativeElement);
            const dragElemClientRect = getMutableClientRect(gridItem.elementRef.nativeElement);
            const scrollableParent = typeof this.scrollableParent === 'string' ? document.getElementById(this.scrollableParent) : this.scrollableParent;
            this.renderer.addClass(gridItem.elementRef.nativeElement, 'no-transitions');
            this.renderer.addClass(gridItem.elementRef.nativeElement, 'ktd-grid-item-dragging');
            const placeholderClientRect = {
                ...dragElemClientRect,
                left: dragElemClientRect.left - gridElemClientRect.left,
                top: dragElemClientRect.top - gridElemClientRect.top
            };
            this.createPlaceholderElement(placeholderClientRect, gridItem.placeholder);
            let newLayout;
            // TODO (enhancement): consider move this 'side effect' observable inside the main drag loop.
            //  - Pros are that we would not repeat subscriptions and takeUntil would shut down observables at the same time.
            //  - Cons are that moving this functionality as a side effect inside the main drag loop would be confusing.
            const scrollSubscription = this.ngZone.runOutsideAngular(() => (!scrollableParent ? NEVER : this.gridService.mouseOrTouchMove$(document).pipe(map((event) => ({
                pointerX: ktdPointerClientX(event),
                pointerY: ktdPointerClientY(event)
            })), ktdScrollIfNearElementClientRect$(scrollableParent, { scrollStep: this.scrollSpeed }))).pipe(takeUntil(ktdMouseOrTouchEnd(document))).subscribe());
            /**
             * Main subscription, it listens for 'pointer move' and 'scroll' events and recalculates the layout on each emission
             */
            const subscription = this.ngZone.runOutsideAngular(() => merge(combineLatest([
                this.gridService.mouseOrTouchMove$(document),
                ...(!scrollableParent ? [of({ top: 0, left: 0 })] : [
                    ktdGetScrollTotalRelativeDifference$(scrollableParent).pipe(startWith({ top: 0, left: 0 }) // Force first emission to allow CombineLatest to emit even no scroll event has occurred
                    )
                ])
            ])).pipe(takeUntil(ktdMouseOrTouchEnd(document))).subscribe(([pointerDragEvent, scrollDifference]) => {
                pointerDragEvent.preventDefault();
                /**
                 * Set the new layout to be the layout in which the calcNewStateFunc would be executed.
                 * NOTE: using the mutated layout is the way to go by 'react-grid-layout' utils. If we don't use the previous layout,
                 * some utilities from 'react-grid-layout' would not work as expected.
                 */
                const currentLayout = newLayout || this.layout;
                // Get the correct newStateFunc depending on if we are dragging or resizing
                const calcNewStateFunc = type === 'drag' ? ktdGridItemDragging : ktdGridItemResizing;
                const { layout, draggedItemPos } = calcNewStateFunc(gridItem, {
                    layout: currentLayout,
                    rowHeight: this.rowHeight,
                    height: this.height,
                    cols: this.cols,
                    preventCollision: this.preventCollision,
                    gap: this.gap,
                }, this.compactType, {
                    pointerDownEvent,
                    pointerDragEvent,
                    gridElemClientRect,
                    dragElemClientRect,
                    scrollDifference
                });
                newLayout = layout;
                this.gridCurrentHeight = this.height ?? (this.rowHeight === 'fit' ? gridElemClientRect.height : getGridHeight(newLayout, this.rowHeight, this.gap));
                this._gridItemsRenderData = layoutToRenderItems({
                    cols: this.cols,
                    rowHeight: this.rowHeight,
                    height: this.height,
                    layout: newLayout,
                    preventCollision: this.preventCollision,
                    gap: this.gap,
                }, gridElemClientRect.width, gridElemClientRect.height);
                const newGridItemRenderData = { ...this._gridItemsRenderData[gridItem.id] };
                const placeholderStyles = parseRenderItemToPixels(newGridItemRenderData);
                // Put the real final position to the placeholder element
                this.placeholder.style.width = placeholderStyles.width;
                this.placeholder.style.height = placeholderStyles.height;
                this.placeholder.style.transform = `translateX(${placeholderStyles.left}) translateY(${placeholderStyles.top})`;
                // modify the position of the dragged item to be the once we want (for example the mouse position or whatever)
                this._gridItemsRenderData[gridItem.id] = {
                    ...draggedItemPos,
                    id: this._gridItemsRenderData[gridItem.id].id
                };
                this.render();
                // If we are performing a resize, and bounds have changed, emit event.
                // NOTE: Only emit on resize for now. Use case for normal drag is not justified for now. Emitting on resize is, since we may want to re-render the grid item or the placeholder in order to fit the new bounds.
                if (type === 'resize') {
                    const prevGridItem = currentLayout.find(item => item.id === gridItem.id);
                    const newGridItem = newLayout.find(item => item.id === gridItem.id);
                    // Check if item resized has changed, if so, emit resize change event
                    if (!ktdGridItemLayoutItemAreEqual(prevGridItem, newGridItem)) {
                        this.gridItemResize.emit({
                            width: newGridItemRenderData.width,
                            height: newGridItemRenderData.height,
                            gridItemRef: getDragResizeEventData(gridItem, newLayout).gridItemRef
                        });
                    }
                }
            }, (error) => observer.error(error), () => {
                this.ngZone.run(() => {
                    // Remove drag classes
                    this.renderer.removeClass(gridItem.elementRef.nativeElement, 'no-transitions');
                    this.renderer.removeClass(gridItem.elementRef.nativeElement, 'ktd-grid-item-dragging');
                    this.destroyPlaceholder();
                    if (newLayout) {
                        // TODO: newLayout should already be pruned. If not, it should have type Layout, not KtdGridLayout as it is now.
                        // Prune react-grid-layout compact extra properties.
                        observer.next(newLayout.map(item => ({
                            id: item.id,
                            x: item.x,
                            y: item.y,
                            w: item.w,
                            h: item.h,
                            minW: item.minW,
                            minH: item.minH,
                            maxW: item.maxW,
                            maxH: item.maxH,
                        })));
                    }
                    else {
                        // TODO: Need we really to emit if there is no layout change but drag started and ended?
                        observer.next(this.layout);
                    }
                    observer.complete();
                });
            }));
            return () => {
                scrollSubscription.unsubscribe();
                subscription.unsubscribe();
            };
        });
    }
    /** Creates placeholder element */
    createPlaceholderElement(clientRect, gridItemPlaceholder) {
        this.placeholder = this.renderer.createElement('div');
        this.placeholder.style.width = `${clientRect.width}px`;
        this.placeholder.style.height = `${clientRect.height}px`;
        this.placeholder.style.transform = `translateX(${clientRect.left}px) translateY(${clientRect.top}px)`;
        this.placeholder.classList.add('ktd-grid-item-placeholder');
        this.renderer.appendChild(this.elementRef.nativeElement, this.placeholder);
        // Create and append custom placeholder if provided.
        // Important: Append it after creating & appending the container placeholder. This way we ensure parent bounds are set when creating the embeddedView.
        if (gridItemPlaceholder) {
            this.placeholderRef = this.viewContainerRef.createEmbeddedView(gridItemPlaceholder.templateRef, gridItemPlaceholder.data);
            this.placeholderRef.rootNodes.forEach(node => this.placeholder.appendChild(node));
            this.placeholderRef.detectChanges();
        }
        else {
            this.placeholder.classList.add('ktd-grid-item-placeholder-default');
        }
    }
    /** Destroys the placeholder element and its ViewRef. */
    destroyPlaceholder() {
        this.placeholder?.remove();
        this.placeholderRef?.destroy();
        this.placeholder = this.placeholderRef = null;
    }
}
KtdGridComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: KtdGridComponent, deps: [{ token: i1.KtdGridService }, { token: i0.ElementRef }, { token: i0.ViewContainerRef }, { token: i0.Renderer2 }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component });
KtdGridComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.2.3", type: KtdGridComponent, selector: "ktd-grid", inputs: { scrollableParent: "scrollableParent", compactOnPropsChange: "compactOnPropsChange", preventCollision: "preventCollision", scrollSpeed: "scrollSpeed", compactType: "compactType", rowHeight: "rowHeight", cols: "cols", layout: "layout", gap: "gap", height: "height" }, outputs: { layoutUpdated: "layoutUpdated", dragStarted: "dragStarted", resizeStarted: "resizeStarted", dragEnded: "dragEnded", resizeEnded: "resizeEnded", gridItemResize: "gridItemResize" }, providers: [
        {
            provide: GRID_ITEM_GET_RENDER_DATA_TOKEN,
            useFactory: ktdGridItemGetRenderDataFactoryFunc,
            deps: [KtdGridComponent]
        }
    ], queries: [{ propertyName: "_gridItems", predicate: KtdGridItemComponent, descendants: true }], usesOnChanges: true, ngImport: i0, template: "<ng-content></ng-content>", styles: ["ktd-grid{display:block;position:relative;width:100%}ktd-grid ktd-grid-item.ktd-grid-item-dragging{z-index:1000}ktd-grid ktd-grid-item.no-transitions{transition:none!important}ktd-grid .ktd-grid-item-placeholder{position:absolute;z-index:0;transition-property:transform;transition:all .15s ease}ktd-grid .ktd-grid-item-placeholder-default{background-color:#8b0000;opacity:.6}\n"], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.3", ngImport: i0, type: KtdGridComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ktd-grid', encapsulation: ViewEncapsulation.None, changeDetection: ChangeDetectionStrategy.OnPush, providers: [
                        {
                            provide: GRID_ITEM_GET_RENDER_DATA_TOKEN,
                            useFactory: ktdGridItemGetRenderDataFactoryFunc,
                            deps: [KtdGridComponent]
                        }
                    ], template: "<ng-content></ng-content>", styles: ["ktd-grid{display:block;position:relative;width:100%}ktd-grid ktd-grid-item.ktd-grid-item-dragging{z-index:1000}ktd-grid ktd-grid-item.no-transitions{transition:none!important}ktd-grid .ktd-grid-item-placeholder{position:absolute;z-index:0;transition-property:transform;transition:all .15s ease}ktd-grid .ktd-grid-item-placeholder-default{background-color:#8b0000;opacity:.6}\n"] }]
        }], ctorParameters: function () { return [{ type: i1.KtdGridService }, { type: i0.ElementRef }, { type: i0.ViewContainerRef }, { type: i0.Renderer2 }, { type: i0.NgZone }]; }, propDecorators: { _gridItems: [{
                type: ContentChildren,
                args: [KtdGridItemComponent, { descendants: true }]
            }], layoutUpdated: [{
                type: Output
            }], dragStarted: [{
                type: Output
            }], resizeStarted: [{
                type: Output
            }], dragEnded: [{
                type: Output
            }], resizeEnded: [{
                type: Output
            }], gridItemResize: [{
                type: Output
            }], scrollableParent: [{
                type: Input
            }], compactOnPropsChange: [{
                type: Input
            }], preventCollision: [{
                type: Input
            }], scrollSpeed: [{
                type: Input
            }], compactType: [{
                type: Input
            }], rowHeight: [{
                type: Input
            }], cols: [{
                type: Input
            }], layout: [{
                type: Input
            }], gap: [{
                type: Input
            }], height: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3JpZC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wcm9qZWN0cy9hbmd1bGFyLWdyaWQtbGF5b3V0L3NyYy9saWIvZ3JpZC5jb21wb25lbnQudHMiLCIuLi8uLi8uLi8uLi9wcm9qZWN0cy9hbmd1bGFyLWdyaWQtbGF5b3V0L3NyYy9saWIvZ3JpZC5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ29DLHVCQUF1QixFQUFFLFNBQVMsRUFBRSxlQUFlLEVBQStCLFlBQVksRUFBRSxLQUFLLEVBQzlHLE1BQU0sRUFBeUQsaUJBQWlCLEVBQ2pILE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxvQkFBb0IsRUFBZSxNQUFNLDRCQUE0QixDQUFDO0FBQy9FLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLGlDQUFpQyxDQUFDO0FBQ3ZFLE9BQU8sRUFBRSxhQUFhLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxVQUFVLEVBQVksRUFBRSxFQUFnQixNQUFNLE1BQU0sQ0FBQztBQUMzRixPQUFPLEVBQUUsVUFBVSxFQUFFLEdBQUcsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ2xGLE9BQU8sRUFBRSx1QkFBdUIsRUFBRSxtQkFBbUIsRUFBRSw2QkFBNkIsRUFBRSxtQkFBbUIsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBQ3RJLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxpQ0FBaUMsQ0FBQztBQUMxRCxPQUFPLEVBQ0gsK0JBQStCLEVBQ2xDLE1BQU0sb0JBQW9CLENBQUM7QUFDNUIsT0FBTyxFQUFFLGtCQUFrQixFQUFFLGlCQUFpQixFQUFFLGlCQUFpQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFHakcsT0FBTyxFQUFFLG9CQUFvQixFQUFpQixNQUFNLHFCQUFxQixDQUFDO0FBQzFFLE9BQU8sRUFBRSxvQ0FB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LE1BQU07Z0JBR0csU0FBUztzQkFBbEIsTUFBTTtnQkFHRyxXQUFXO3NCQUFwQixNQUFNO2dCQUdHLGNBQWM7c0JBQXZCLE1BQU07Z0JBTUUsZ0JBQWdCO3NCQUF4QixLQUFLO2dCQUlGLG9CQUFvQjtzQkFEdkIsS0FBSztnQkFXRixnQkFBZ0I7c0JBRG5CLEtBQUs7Z0JBV0YsV0FBVztzQkFEZCxLQUFLO2dCQVdGLFdBQVc7c0JBRGQsS0FBSztnQkFpQkYsU0FBUztzQkFEWixLQUFLO2dCQVdGLElBQUk7c0JBRFAsS0FBSztnQkFXRixNQUFNO3NCQURULEtBQUs7Z0JBb0JGLEdBQUc7c0JBRE4sS0FBSztnQkFrQkYsTUFBTTtzQkFEVCxLQUFLIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcclxuICAgIEFmdGVyQ29udGVudENoZWNrZWQsIEFmdGVyQ29udGVudEluaXQsIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDb21wb25lbnQsIENvbnRlbnRDaGlsZHJlbiwgRWxlbWVudFJlZiwgRW1iZWRkZWRWaWV3UmVmLCBFdmVudEVtaXR0ZXIsIElucHV0LFxyXG4gICAgTmdab25lLCBPbkNoYW5nZXMsIE9uRGVzdHJveSwgT3V0cHV0LCBRdWVyeUxpc3QsIFJlbmRlcmVyMiwgU2ltcGxlQ2hhbmdlcywgVmlld0NvbnRhaW5lclJlZiwgVmlld0VuY2Fwc3VsYXRpb25cclxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgY29lcmNlTnVtYmVyUHJvcGVydHksIE51bWJlcklucHV0IH0gZnJvbSAnLi9jb2VyY2lvbi9udW1iZXItcHJvcGVydHknO1xyXG5pbXBvcnQgeyBLdGRHcmlkSXRlbUNvbXBvbmVudCB9IGZyb20gJy4vZ3JpZC1pdGVtL2dyaWQtaXRlbS5jb21wb25lbnQnO1xyXG5pbXBvcnQgeyBjb21iaW5lTGF0ZXN0LCBtZXJnZSwgTkVWRVIsIE9ic2VydmFibGUsIE9ic2VydmVyLCBvZiwgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IGV4aGF1c3RNYXAsIG1hcCwgc3RhcnRXaXRoLCBzd2l0Y2hNYXAsIHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuaW1wb3J0IHsga3RkR2V0R3JpZEl0ZW1Sb3dIZWlnaHQsIGt0ZEdyaWRJdGVtRHJhZ2dpbmcsIGt0ZEdyaWRJdGVtTGF5b3V0SXRlbUFyZUVxdWFsLCBrdGRHcmlkSXRlbVJlc2l6aW5nIH0gZnJvbSAnLi91dGlscy9ncmlkLnV0aWxzJztcclxuaW1wb3J0IHsgY29tcGFjdCB9IGZyb20gJy4vdXRpbHMvcmVhY3QtZ3JpZC1sYXlvdXQudXRpbHMnO1xyXG5pbXBvcnQge1xyXG4gICAgR1JJRF9JVEVNX0dFVF9SRU5ERVJfREFUQV9UT0tFTiwgS3RkR3JpZENmZywgS3RkR3JpZENvbXBhY3RUeXBlLCBLdGRHcmlkSXRlbVJlbmRlckRhdGEsIEt0ZEdyaWRMYXlvdXQsIEt0ZEdyaWRMYXlvdXRJdGVtXHJcbn0gZnJvbSAnLi9ncmlkLmRlZmluaXRpb25zJztcclxuaW1wb3J0IHsga3RkTW91c2VPclRvdWNoRW5kLCBrdGRQb2ludGVyQ2xpZW50WCwga3RkUG9pbnRlckNsaWVudFkgfSBmcm9tICcuL3V0aWxzL3BvaW50ZXIudXRpbHMnO1xyXG5pbXBvcnQgeyBLdGREaWN0aW9uYXJ5IH0gZnJvbSAnLi4vdHlwZXMnO1xyXG5pbXBvcnQgeyBLdGRHcmlkU2VydmljZSB9IGZyb20gJy4vZ3JpZC5zZXJ2aWNlJztcclxuaW1wb3J0IHsgZ2V0TXV0YWJsZUNsaWVudFJlY3QsIEt0ZENsaWVudFJlY3QgfSBmcm9tICcuL3V0aWxzL2NsaWVudC1yZWN0JztcclxuaW1wb3J0IHsga3RkR2V0U2Nyb2xsVG90YWxSZWxhdGl2ZURpZmZlcmVuY2UkLCBrdGRTY3JvbGxJZk5lYXJFbGVtZW50Q2xpZW50UmVjdCQgfSBmcm9tICcuL3V0aWxzL3Njcm9sbCc7XHJcbmltcG9ydCB7IEJvb2xlYW5JbnB1dCwgY29lcmNlQm9vbGVhblByb3BlcnR5IH0gZnJvbSAnLi9jb2VyY2lvbi9ib29sZWFuLXByb3BlcnR5JztcclxuaW1wb3J0IHsgS3RkR3JpZEl0ZW1QbGFjZWhvbGRlciB9IGZyb20gJy4vZGlyZWN0aXZlcy9wbGFjZWhvbGRlcic7XHJcblxyXG5pbnRlcmZhY2UgS3RkRHJhZ1Jlc2l6ZUV2ZW50IHtcclxuICAgIGxheW91dDogS3RkR3JpZExheW91dDtcclxuICAgIGxheW91dEl0ZW06IEt0ZEdyaWRMYXlvdXRJdGVtO1xyXG4gICAgZ3JpZEl0ZW1SZWY6IEt0ZEdyaWRJdGVtQ29tcG9uZW50O1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBLdGREcmFnU3RhcnQgPSBLdGREcmFnUmVzaXplRXZlbnQ7XHJcbmV4cG9ydCB0eXBlIEt0ZFJlc2l6ZVN0YXJ0ID0gS3RkRHJhZ1Jlc2l6ZUV2ZW50O1xyXG5leHBvcnQgdHlwZSBLdGREcmFnRW5kID0gS3RkRHJhZ1Jlc2l6ZUV2ZW50O1xyXG5leHBvcnQgdHlwZSBLdGRSZXNpemVFbmQgPSBLdGREcmFnUmVzaXplRXZlbnQ7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEt0ZEdyaWRJdGVtUmVzaXplRXZlbnQge1xyXG4gICAgd2lkdGg6IG51bWJlcjtcclxuICAgIGhlaWdodDogbnVtYmVyO1xyXG4gICAgZ3JpZEl0ZW1SZWY6IEt0ZEdyaWRJdGVtQ29tcG9uZW50O1xyXG59XHJcblxyXG50eXBlIERyYWdBY3Rpb25UeXBlID0gJ2RyYWcnIHwgJ3Jlc2l6ZSc7XHJcblxyXG5mdW5jdGlvbiBnZXREcmFnUmVzaXplRXZlbnREYXRhKGdyaWRJdGVtOiBLdGRHcmlkSXRlbUNvbXBvbmVudCwgbGF5b3V0OiBLdGRHcmlkTGF5b3V0KTogS3RkRHJhZ1Jlc2l6ZUV2ZW50IHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbGF5b3V0LFxyXG4gICAgICAgIGxheW91dEl0ZW06IGxheW91dC5maW5kKChpdGVtKSA9PiBpdGVtLmlkID09PSBncmlkSXRlbS5pZCkhLFxyXG4gICAgICAgIGdyaWRJdGVtUmVmOiBncmlkSXRlbVxyXG4gICAgfTtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIGxheW91dFRvUmVuZGVySXRlbXMoY29uZmlnOiBLdGRHcmlkQ2ZnLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcik6IEt0ZERpY3Rpb25hcnk8S3RkR3JpZEl0ZW1SZW5kZXJEYXRhPG51bWJlcj4+IHtcclxuICAgIGNvbnN0IHtjb2xzLCByb3dIZWlnaHQsIGxheW91dCwgZ2FwfSA9IGNvbmZpZztcclxuICAgIGNvbnN0IHJvd0hlaWdodEluUGl4ZWxzID0gcm93SGVpZ2h0ID09PSAnZml0JyA/IGt0ZEdldEdyaWRJdGVtUm93SGVpZ2h0KGxheW91dCwgaGVpZ2h0LCBnYXApIDogcm93SGVpZ2h0O1xyXG4gICAgY29uc3Qgd2lkdGhFeGNsdWRpbmdHYXAgPSB3aWR0aCAtIE1hdGgubWF4KChnYXAgKiAoY29scyAtIDEpKSwgMCk7XHJcbiAgICBjb25zdCBpdGVtV2lkdGhQZXJDb2x1bW4gPSAod2lkdGhFeGNsdWRpbmdHYXAgLyBjb2xzKTtcclxuICAgIGNvbnN0IHJlbmRlckl0ZW1zOiBLdGREaWN0aW9uYXJ5PEt0ZEdyaWRJdGVtUmVuZGVyRGF0YTxudW1iZXI+PiA9IHt9O1xyXG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGxheW91dCkge1xyXG4gICAgICAgIHJlbmRlckl0ZW1zW2l0ZW0uaWRdID0ge1xyXG4gICAgICAgICAgICBpZDogaXRlbS5pZCxcclxuICAgICAgICAgICAgdG9wOiBpdGVtLnkgKiByb3dIZWlnaHRJblBpeGVscyArIGdhcCAqIGl0ZW0ueSxcclxuICAgICAgICAgICAgbGVmdDogaXRlbS54ICogaXRlbVdpZHRoUGVyQ29sdW1uICsgZ2FwICogaXRlbS54LFxyXG4gICAgICAgICAgICB3aWR0aDogaXRlbS53ICogaXRlbVdpZHRoUGVyQ29sdW1uICsgZ2FwICogTWF0aC5tYXgoaXRlbS53IC0gMSwgMCksXHJcbiAgICAgICAgICAgIGhlaWdodDogaXRlbS5oICogcm93SGVpZ2h0SW5QaXhlbHMgKyBnYXAgKiBNYXRoLm1heChpdGVtLmggLSAxLCAwKSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlbmRlckl0ZW1zO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRHcmlkSGVpZ2h0KGxheW91dDogS3RkR3JpZExheW91dCwgcm93SGVpZ2h0OiBudW1iZXIsIGdhcDogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgIHJldHVybiBsYXlvdXQucmVkdWNlKChhY2MsIGN1cikgPT4gTWF0aC5tYXgoYWNjLCAoY3VyLnkgKyBjdXIuaCkgKiByb3dIZWlnaHQgKyBNYXRoLm1heChjdXIueSArIGN1ci5oIC0gMSwgMCkgKiBnYXApLCAwKTtcclxufVxyXG5cclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEBrYXRvaWQvcHJlZml4LWV4cG9ydGVkLWNvZGVcclxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUmVuZGVySXRlbVRvUGl4ZWxzKHJlbmRlckl0ZW06IEt0ZEdyaWRJdGVtUmVuZGVyRGF0YTxudW1iZXI+KTogS3RkR3JpZEl0ZW1SZW5kZXJEYXRhPHN0cmluZz4ge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBpZDogcmVuZGVySXRlbS5pZCxcclxuICAgICAgICB0b3A6IGAke3JlbmRlckl0ZW0udG9wfXB4YCxcclxuICAgICAgICBsZWZ0OiBgJHtyZW5kZXJJdGVtLmxlZnR9cHhgLFxyXG4gICAgICAgIHdpZHRoOiBgJHtyZW5kZXJJdGVtLndpZHRofXB4YCxcclxuICAgICAgICBoZWlnaHQ6IGAke3JlbmRlckl0ZW0uaGVpZ2h0fXB4YFxyXG4gICAgfTtcclxufVxyXG5cclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEBrYXRvaWQvcHJlZml4LWV4cG9ydGVkLWNvZGVcclxuZXhwb3J0IGZ1bmN0aW9uIF9fZ3JpZEl0ZW1HZXRSZW5kZXJEYXRhRmFjdG9yeUZ1bmMoZ3JpZENtcDogS3RkR3JpZENvbXBvbmVudCkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGlkOiBzdHJpbmcpIHtcclxuICAgICAgICByZXR1cm4gcGFyc2VSZW5kZXJJdGVtVG9QaXhlbHMoZ3JpZENtcC5nZXRJdGVtUmVuZGVyRGF0YShpZCkpO1xyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGt0ZEdyaWRJdGVtR2V0UmVuZGVyRGF0YUZhY3RvcnlGdW5jKGdyaWRDbXA6IEt0ZEdyaWRDb21wb25lbnQpIHtcclxuICAgIC8vIFdvcmthcm91bmQgZXhwbGFpbmVkOiBodHRwczovL2dpdGh1Yi5jb20vbmctcGFja2Fnci9uZy1wYWNrYWdyL2lzc3Vlcy82OTYjaXNzdWVjb21tZW50LTM4NzExNDYxM1xyXG4gICAgY29uc3QgcmVzdWx0RnVuYyA9IF9fZ3JpZEl0ZW1HZXRSZW5kZXJEYXRhRmFjdG9yeUZ1bmMoZ3JpZENtcCk7XHJcbiAgICByZXR1cm4gcmVzdWx0RnVuYztcclxufVxyXG5cclxuXHJcbkBDb21wb25lbnQoe1xyXG4gICAgc2VsZWN0b3I6ICdrdGQtZ3JpZCcsXHJcbiAgICB0ZW1wbGF0ZVVybDogJy4vZ3JpZC5jb21wb25lbnQuaHRtbCcsXHJcbiAgICBzdHlsZVVybHM6IFsnLi9ncmlkLmNvbXBvbmVudC5zY3NzJ10sXHJcbiAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxyXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXHJcbiAgICBwcm92aWRlcnM6IFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHByb3ZpZGU6IEdSSURfSVRFTV9HRVRfUkVOREVSX0RBVEFfVE9LRU4sXHJcbiAgICAgICAgICAgIHVzZUZhY3Rvcnk6IGt0ZEdyaWRJdGVtR2V0UmVuZGVyRGF0YUZhY3RvcnlGdW5jLFxyXG4gICAgICAgICAgICBkZXBzOiBbS3RkR3JpZENvbXBvbmVudF1cclxuICAgICAgICB9XHJcbiAgICBdXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBLdGRHcmlkQ29tcG9uZW50IGltcGxlbWVudHMgT25DaGFuZ2VzLCBBZnRlckNvbnRlbnRJbml0LCBBZnRlckNvbnRlbnRDaGVja2VkLCBPbkRlc3Ryb3kge1xyXG4gICAgLyoqIFF1ZXJ5IGxpc3Qgb2YgZ3JpZCBpdGVtcyB0aGF0IGFyZSBiZWluZyByZW5kZXJlZC4gKi9cclxuICAgIEBDb250ZW50Q2hpbGRyZW4oS3RkR3JpZEl0ZW1Db21wb25lbnQsIHtkZXNjZW5kYW50czogdHJ1ZX0pIF9ncmlkSXRlbXM6IFF1ZXJ5TGlzdDxLdGRHcmlkSXRlbUNvbXBvbmVudD47XHJcblxyXG4gICAgLyoqIEVtaXRzIHdoZW4gbGF5b3V0IGNoYW5nZSAqL1xyXG4gICAgQE91dHB1dCgpIGxheW91dFVwZGF0ZWQ6IEV2ZW50RW1pdHRlcjxLdGRHcmlkTGF5b3V0PiA9IG5ldyBFdmVudEVtaXR0ZXI8S3RkR3JpZExheW91dD4oKTtcclxuXHJcbiAgICAvKiogRW1pdHMgd2hlbiBkcmFnIHN0YXJ0cyAqL1xyXG4gICAgQE91dHB1dCgpIGRyYWdTdGFydGVkOiBFdmVudEVtaXR0ZXI8S3RkRHJhZ1N0YXJ0PiA9IG5ldyBFdmVudEVtaXR0ZXI8S3RkRHJhZ1N0YXJ0PigpO1xyXG5cclxuICAgIC8qKiBFbWl0cyB3aGVuIHJlc2l6ZSBzdGFydHMgKi9cclxuICAgIEBPdXRwdXQoKSByZXNpemVTdGFydGVkOiBFdmVudEVtaXR0ZXI8S3RkUmVzaXplU3RhcnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxLdGRSZXNpemVTdGFydD4oKTtcclxuXHJcbiAgICAvKiogRW1pdHMgd2hlbiBkcmFnIGVuZHMgKi9cclxuICAgIEBPdXRwdXQoKSBkcmFnRW5kZWQ6IEV2ZW50RW1pdHRlcjxLdGREcmFnRW5kPiA9IG5ldyBFdmVudEVtaXR0ZXI8S3RkRHJhZ0VuZD4oKTtcclxuXHJcbiAgICAvKiogRW1pdHMgd2hlbiByZXNpemUgZW5kcyAqL1xyXG4gICAgQE91dHB1dCgpIHJlc2l6ZUVuZGVkOiBFdmVudEVtaXR0ZXI8S3RkUmVzaXplRW5kPiA9IG5ldyBFdmVudEVtaXR0ZXI8S3RkUmVzaXplRW5kPigpO1xyXG5cclxuICAgIC8qKiBFbWl0cyB3aGVuIGEgZ3JpZCBpdGVtIGlzIGJlaW5nIHJlc2l6ZWQgYW5kIGl0cyBib3VuZHMgaGF2ZSBjaGFuZ2VkICovXHJcbiAgICBAT3V0cHV0KCkgZ3JpZEl0ZW1SZXNpemU6IEV2ZW50RW1pdHRlcjxLdGRHcmlkSXRlbVJlc2l6ZUV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8S3RkR3JpZEl0ZW1SZXNpemVFdmVudD4oKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFBhcmVudCBlbGVtZW50IHRoYXQgY29udGFpbnMgdGhlIHNjcm9sbC4gSWYgYW4gc3RyaW5nIGlzIHByb3ZpZGVkIGl0IHdvdWxkIHNlYXJjaCB0aGF0IGVsZW1lbnQgYnkgaWQgb24gdGhlIGRvbS5cclxuICAgICAqIElmIG5vIGRhdGEgcHJvdmlkZWQgb3IgbnVsbCBhdXRvc2Nyb2xsIGlzIG5vdCBwZXJmb3JtZWQuXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpIHNjcm9sbGFibGVQYXJlbnQ6IEhUTUxFbGVtZW50IHwgRG9jdW1lbnQgfCBzdHJpbmcgfCBudWxsID0gbnVsbDtcclxuXHJcbiAgICAvKiogV2hldGhlciBvciBub3QgdG8gdXBkYXRlIHRoZSBpbnRlcm5hbCBsYXlvdXQgd2hlbiBzb21lIGRlcGVuZGVudCBwcm9wZXJ0eSBjaGFuZ2UuICovXHJcbiAgICBASW5wdXQoKVxyXG4gICAgZ2V0IGNvbXBhY3RPblByb3BzQ2hhbmdlKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5fY29tcGFjdE9uUHJvcHNDaGFuZ2U7IH1cclxuXHJcbiAgICBzZXQgY29tcGFjdE9uUHJvcHNDaGFuZ2UodmFsdWU6IGJvb2xlYW4pIHtcclxuICAgICAgICB0aGlzLl9jb21wYWN0T25Qcm9wc0NoYW5nZSA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfY29tcGFjdE9uUHJvcHNDaGFuZ2U6IGJvb2xlYW4gPSB0cnVlO1xyXG5cclxuICAgIC8qKiBJZiB0cnVlLCBncmlkIGl0ZW1zIHdvbid0IGNoYW5nZSBwb3NpdGlvbiB3aGVuIGJlaW5nIGRyYWdnZWQgb3Zlci4gSGFuZHkgd2hlbiB1c2luZyBubyBjb21wYWN0aW9uICovXHJcbiAgICBASW5wdXQoKVxyXG4gICAgZ2V0IHByZXZlbnRDb2xsaXNpb24oKTogYm9vbGVhbiB7IHJldHVybiB0aGlzLl9wcmV2ZW50Q29sbGlzaW9uOyB9XHJcblxyXG4gICAgc2V0IHByZXZlbnRDb2xsaXNpb24odmFsdWU6IGJvb2xlYW4pIHtcclxuICAgICAgICB0aGlzLl9wcmV2ZW50Q29sbGlzaW9uID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9wcmV2ZW50Q29sbGlzaW9uOiBib29sZWFuID0gZmFsc2U7XHJcblxyXG4gICAgLyoqIE51bWJlciBvZiBDU1MgcGl4ZWxzIHRoYXQgd291bGQgYmUgc2Nyb2xsZWQgb24gZWFjaCAndGljaycgd2hlbiBhdXRvIHNjcm9sbCBpcyBwZXJmb3JtZWQuICovXHJcbiAgICBASW5wdXQoKVxyXG4gICAgZ2V0IHNjcm9sbFNwZWVkKCk6IG51bWJlciB7IHJldHVybiB0aGlzLl9zY3JvbGxTcGVlZDsgfVxyXG5cclxuICAgIHNldCBzY3JvbGxTcGVlZCh2YWx1ZTogbnVtYmVyKSB7XHJcbiAgICAgICAgdGhpcy5fc2Nyb2xsU3BlZWQgPSBjb2VyY2VOdW1iZXJQcm9wZXJ0eSh2YWx1ZSwgMik7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfc2Nyb2xsU3BlZWQ6IG51bWJlciA9IDI7XHJcblxyXG4gICAgLyoqIFR5cGUgb2YgY29tcGFjdGlvbiB0aGF0IHdpbGwgYmUgYXBwbGllZCB0byB0aGUgbGF5b3V0ICh2ZXJ0aWNhbCwgaG9yaXpvbnRhbCBvciBmcmVlKS4gRGVmYXVsdHMgdG8gJ3ZlcnRpY2FsJyAqL1xyXG4gICAgQElucHV0KClcclxuICAgIGdldCBjb21wYWN0VHlwZSgpOiBLdGRHcmlkQ29tcGFjdFR5cGUge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jb21wYWN0VHlwZTtcclxuICAgIH1cclxuXHJcbiAgICBzZXQgY29tcGFjdFR5cGUodmFsOiBLdGRHcmlkQ29tcGFjdFR5cGUpIHtcclxuICAgICAgICB0aGlzLl9jb21wYWN0VHlwZSA9IHZhbDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9jb21wYWN0VHlwZTogS3RkR3JpZENvbXBhY3RUeXBlID0gJ3ZlcnRpY2FsJztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJvdyBoZWlnaHQgYXMgbnVtYmVyIG9yIGFzICdmaXQnLlxyXG4gICAgICogSWYgcm93SGVpZ2h0IGlzIGEgbnVtYmVyIHZhbHVlLCBpdCBtZWFucyB0aGF0IGVhY2ggcm93IHdvdWxkIGhhdmUgdGhvc2UgY3NzIHBpeGVscyBpbiBoZWlnaHQuXHJcbiAgICAgKiBpZiByb3dIZWlnaHQgaXMgJ2ZpdCcsIGl0IG1lYW5zIHRoYXQgcm93cyB3aWxsIGZpdCBpbiB0aGUgaGVpZ2h0IGF2YWlsYWJsZS4gSWYgJ2ZpdCcgdmFsdWUgaXMgc2V0LCBhICdoZWlnaHQnIHNob3VsZCBiZSBhbHNvIHByb3ZpZGVkLlxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKVxyXG4gICAgZ2V0IHJvd0hlaWdodCgpOiBudW1iZXIgfCAnZml0JyB7IHJldHVybiB0aGlzLl9yb3dIZWlnaHQ7IH1cclxuXHJcbiAgICBzZXQgcm93SGVpZ2h0KHZhbDogbnVtYmVyIHwgJ2ZpdCcpIHtcclxuICAgICAgICB0aGlzLl9yb3dIZWlnaHQgPSB2YWwgPT09ICdmaXQnID8gdmFsIDogTWF0aC5tYXgoMSwgTWF0aC5yb3VuZChjb2VyY2VOdW1iZXJQcm9wZXJ0eSh2YWwpKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfcm93SGVpZ2h0OiBudW1iZXIgfCAnZml0JyA9IDEwMDtcclxuXHJcbiAgICAvKiogTnVtYmVyIG9mIGNvbHVtbnMgICovXHJcbiAgICBASW5wdXQoKVxyXG4gICAgZ2V0IGNvbHMoKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMuX2NvbHM7IH1cclxuXHJcbiAgICBzZXQgY29scyh2YWw6IG51bWJlcikge1xyXG4gICAgICAgIHRoaXMuX2NvbHMgPSBNYXRoLm1heCgxLCBNYXRoLnJvdW5kKGNvZXJjZU51bWJlclByb3BlcnR5KHZhbCkpKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9jb2xzOiBudW1iZXIgPSA2O1xyXG5cclxuICAgIC8qKiBMYXlvdXQgb2YgdGhlIGdyaWQuIEFycmF5IG9mIGFsbCB0aGUgZ3JpZCBpdGVtcyB3aXRoIGl0cyAnaWQnIGFuZCBwb3NpdGlvbiBvbiB0aGUgZ3JpZC4gKi9cclxuICAgIEBJbnB1dCgpXHJcbiAgICBnZXQgbGF5b3V0KCk6IEt0ZEdyaWRMYXlvdXQgeyByZXR1cm4gdGhpcy5fbGF5b3V0OyB9XHJcblxyXG4gICAgc2V0IGxheW91dChsYXlvdXQ6IEt0ZEdyaWRMYXlvdXQpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFbmhhbmNlbWVudDpcclxuICAgICAgICAgKiBPbmx5IHNldCBsYXlvdXQgaWYgaXQncyByZWZlcmVuY2UgaGFzIGNoYW5nZWQgYW5kIHVzZSBhIGJvb2xlYW4gdG8gdHJhY2sgd2hlbmV2ZXIgcmVjYWxjdWxhdGUgdGhlIGxheW91dCBvbiBuZ09uQ2hhbmdlcy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFdoeTpcclxuICAgICAgICAgKiBUaGUgbm9ybWFsIHVzZSBvZiB0aGlzIGxpYiBpcyBoYXZpbmcgdGhlIHZhcmlhYmxlIGxheW91dCBpbiB0aGUgb3V0ZXIgY29tcG9uZW50IG9yIGluIGEgc3RvcmUsIGFzc2lnbmluZyBpdCB3aGVuZXZlciBpdCBjaGFuZ2VzIGFuZFxyXG4gICAgICAgICAqIGJpbmRlZCBpbiB0aGUgY29tcG9uZW50IHdpdGggaXQncyBpbnB1dCBbbGF5b3V0XS4gSW4gdGhpcyBzY2VuYXJpbywgd2Ugd291bGQgYWx3YXlzIGNhbGN1bGF0ZSBvbmUgdW5uZWNlc3NhcnkgY2hhbmdlIG9uIHRoZSBsYXlvdXQgd2hlblxyXG4gICAgICAgICAqIGl0IGlzIHJlLWJpbmRlZCBvbiB0aGUgaW5wdXQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fbGF5b3V0ID0gbGF5b3V0O1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX2xheW91dDogS3RkR3JpZExheW91dDtcclxuXHJcbiAgICAvKiogR3JpZCBnYXAgaW4gY3NzIHBpeGVscyAqL1xyXG4gICAgQElucHV0KClcclxuICAgIGdldCBnYXAoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ2FwO1xyXG4gICAgfVxyXG5cclxuICAgIHNldCBnYXAodmFsOiBudW1iZXIpIHtcclxuICAgICAgICB0aGlzLl9nYXAgPSBNYXRoLm1heChjb2VyY2VOdW1iZXJQcm9wZXJ0eSh2YWwpLCAwKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9nYXA6IG51bWJlciA9IDA7XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSWYgaGVpZ2h0IGlzIGEgbnVtYmVyLCBmaXhlcyB0aGUgaGVpZ2h0IG9mIHRoZSBncmlkIHRvIGl0LCByZWNvbW1lbmRlZCB3aGVuIHJvd0hlaWdodCA9ICdmaXQnIGlzIHVzZWQuXHJcbiAgICAgKiBJZiBoZWlnaHQgaXMgbnVsbCwgaGVpZ2h0IHdpbGwgYmUgYXV0b21hdGljYWxseSBzZXQgYWNjb3JkaW5nIHRvIGl0cyBpbm5lciBncmlkIGl0ZW1zLlxyXG4gICAgICogRGVmYXVsdHMgdG8gbnVsbC5cclxuICAgICAqICovXHJcbiAgICBASW5wdXQoKVxyXG4gICAgZ2V0IGhlaWdodCgpOiBudW1iZXIgfCBudWxsIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faGVpZ2h0O1xyXG4gICAgfVxyXG5cclxuICAgIHNldCBoZWlnaHQodmFsOiBudW1iZXIgfCBudWxsKSB7XHJcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gdHlwZW9mIHZhbCA9PT0gJ251bWJlcicgPyBNYXRoLm1heCh2YWwsIDApIDogbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9oZWlnaHQ6IG51bWJlciB8IG51bGwgPSBudWxsO1xyXG4gICAgcHJpdmF0ZSBncmlkQ3VycmVudEhlaWdodDogbnVtYmVyO1xyXG5cclxuICAgIGdldCBjb25maWcoKTogS3RkR3JpZENmZyB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgY29sczogdGhpcy5jb2xzLFxyXG4gICAgICAgICAgICByb3dIZWlnaHQ6IHRoaXMucm93SGVpZ2h0LFxyXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxyXG4gICAgICAgICAgICBsYXlvdXQ6IHRoaXMubGF5b3V0LFxyXG4gICAgICAgICAgICBwcmV2ZW50Q29sbGlzaW9uOiB0aGlzLnByZXZlbnRDb2xsaXNpb24sXHJcbiAgICAgICAgICAgIGdhcDogdGhpcy5nYXAsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogUmVmZXJlbmNlIHRvIHRoZSB2aWV3IG9mIHRoZSBwbGFjZWhvbGRlciBlbGVtZW50LiAqL1xyXG4gICAgcHJpdmF0ZSBwbGFjZWhvbGRlclJlZjogRW1iZWRkZWRWaWV3UmVmPGFueT4gfCBudWxsO1xyXG5cclxuICAgIC8qKiBFbGVtZW50IHRoYXQgaXMgcmVuZGVyZWQgYXMgcGxhY2Vob2xkZXIgd2hlbiBhIGdyaWQgaXRlbSBpcyBiZWluZyBkcmFnZ2VkICovXHJcbiAgICBwcml2YXRlIHBsYWNlaG9sZGVyOiBIVE1MRWxlbWVudCB8IG51bGw7XHJcblxyXG4gICAgcHJpdmF0ZSBfZ3JpZEl0ZW1zUmVuZGVyRGF0YTogS3RkRGljdGlvbmFyeTxLdGRHcmlkSXRlbVJlbmRlckRhdGE8bnVtYmVyPj47XHJcbiAgICBwcml2YXRlIHN1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbltdO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgZ3JpZFNlcnZpY2U6IEt0ZEdyaWRTZXJ2aWNlLFxyXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBlbGVtZW50UmVmOiBFbGVtZW50UmVmLFxyXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSB2aWV3Q29udGFpbmVyUmVmOiBWaWV3Q29udGFpbmVyUmVmLFxyXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSByZW5kZXJlcjogUmVuZGVyZXIyLFxyXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBuZ1pvbmU6IE5nWm9uZSkge1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKSB7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnJvd0hlaWdodCA9PT0gJ2ZpdCcgJiYgdGhpcy5oZWlnaHQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYEt0ZEdyaWRDb21wb25lbnQ6IFRoZSBASW5wdXQoKSBoZWlnaHQgc2hvdWxkIG5vdCBiZSBudWxsIHdoZW4gdXNpbmcgcm93SGVpZ2h0ICdmaXQnYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgbmVlZHNDb21wYWN0TGF5b3V0ID0gZmFsc2U7XHJcbiAgICAgICAgbGV0IG5lZWRzUmVjYWxjdWxhdGVSZW5kZXJEYXRhID0gZmFsc2U7XHJcblxyXG4gICAgICAgIC8vIFRPRE86IERvZXMgZmlzdCBjaGFuZ2UgbmVlZCB0byBiZSBjb21wYWN0ZWQgYnkgZGVmYXVsdD9cclxuICAgICAgICAvLyBDb21wYWN0IGxheW91dCB3aGVuZXZlciBzb21lIGRlcGVuZGVudCBwcm9wIGNoYW5nZXMuXHJcbiAgICAgICAgaWYgKGNoYW5nZXMuY29tcGFjdFR5cGUgfHwgY2hhbmdlcy5jb2xzIHx8IGNoYW5nZXMubGF5b3V0KSB7XHJcbiAgICAgICAgICAgIG5lZWRzQ29tcGFjdExheW91dCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDaGVjayBpZiB3ZWUgbmVlZCB0byByZWNhbGN1bGF0ZSByZW5kZXJpbmcgZGF0YS5cclxuICAgICAgICBpZiAobmVlZHNDb21wYWN0TGF5b3V0IHx8IGNoYW5nZXMucm93SGVpZ2h0IHx8IGNoYW5nZXMuaGVpZ2h0IHx8IGNoYW5nZXMuZ2FwKSB7XHJcbiAgICAgICAgICAgIG5lZWRzUmVjYWxjdWxhdGVSZW5kZXJEYXRhID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE9ubHkgY29tcGFjdCBsYXlvdXQgaWYgbGliIHVzZXIgaGFzIHByb3ZpZGVkIGl0LiBMaWIgdXNlcnMgdGhhdCB3YW50IHRvIHNhdmUvc3RvcmUgYWx3YXlzIHRoZSBzYW1lIGxheW91dCAgYXMgaXQgaXMgcmVwcmVzZW50ZWQgKGNvbXBhY3RlZClcclxuICAgICAgICAvLyBjYW4gdXNlIEt0ZENvbXBhY3RHcmlkIHV0aWxpdHkgYW5kIHByZS1jb21wYWN0IHRoZSBsYXlvdXQuIFRoaXMgaXMgdGhlIHJlY29tbWVuZGVkIGJlaGF2aW91ciBmb3IgYWx3YXlzIGhhdmluZyBhIHRoZSBzYW1lIGxheW91dCBvbiB0aGlzIGNvbXBvbmVudFxyXG4gICAgICAgIC8vIGFuZCB0aGUgb25lcyB0aGF0IHVzZXMgaXQuXHJcbiAgICAgICAgaWYgKG5lZWRzQ29tcGFjdExheW91dCAmJiB0aGlzLmNvbXBhY3RPblByb3BzQ2hhbmdlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29tcGFjdExheW91dCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG5lZWRzUmVjYWxjdWxhdGVSZW5kZXJEYXRhKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlUmVuZGVyRGF0YSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XHJcbiAgICAgICAgdGhpcy5pbml0U3Vic2NyaXB0aW9ucygpO1xyXG4gICAgfVxyXG5cclxuICAgIG5nQWZ0ZXJDb250ZW50Q2hlY2tlZCgpIHtcclxuICAgICAgICB0aGlzLnJlbmRlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIHJlc2l6ZSgpIHtcclxuICAgICAgICB0aGlzLmNhbGN1bGF0ZVJlbmRlckRhdGEoKTtcclxuICAgICAgICB0aGlzLnJlbmRlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIG5nT25EZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKHN1YiA9PiBzdWIudW5zdWJzY3JpYmUoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29tcGFjdExheW91dCgpIHtcclxuICAgICAgICB0aGlzLmxheW91dCA9IGNvbXBhY3QodGhpcy5sYXlvdXQsIHRoaXMuY29tcGFjdFR5cGUsIHRoaXMuY29scyk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0SXRlbXNSZW5kZXJEYXRhKCk6IEt0ZERpY3Rpb25hcnk8S3RkR3JpZEl0ZW1SZW5kZXJEYXRhPG51bWJlcj4+IHtcclxuICAgICAgICByZXR1cm4gey4uLnRoaXMuX2dyaWRJdGVtc1JlbmRlckRhdGF9O1xyXG4gICAgfVxyXG5cclxuICAgIGdldEl0ZW1SZW5kZXJEYXRhKGl0ZW1JZDogc3RyaW5nKTogS3RkR3JpZEl0ZW1SZW5kZXJEYXRhPG51bWJlcj4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9ncmlkSXRlbXNSZW5kZXJEYXRhW2l0ZW1JZF07XHJcbiAgICB9XHJcblxyXG4gICAgY2FsY3VsYXRlUmVuZGVyRGF0YSgpIHtcclxuICAgICAgICBjb25zdCBjbGllbnRSZWN0ID0gKHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50IGFzIEhUTUxFbGVtZW50KS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICB0aGlzLmdyaWRDdXJyZW50SGVpZ2h0ID0gdGhpcy5oZWlnaHQgPz8gKHRoaXMucm93SGVpZ2h0ID09PSAnZml0JyA/IGNsaWVudFJlY3QuaGVpZ2h0IDogZ2V0R3JpZEhlaWdodCh0aGlzLmxheW91dCwgdGhpcy5yb3dIZWlnaHQsIHRoaXMuZ2FwKSk7XHJcbiAgICAgICAgdGhpcy5fZ3JpZEl0ZW1zUmVuZGVyRGF0YSA9IGxheW91dFRvUmVuZGVySXRlbXModGhpcy5jb25maWcsIGNsaWVudFJlY3Qud2lkdGgsIHRoaXMuZ3JpZEN1cnJlbnRIZWlnaHQpO1xyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlcigpIHtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnaGVpZ2h0JywgYCR7dGhpcy5ncmlkQ3VycmVudEhlaWdodH1weGApO1xyXG4gICAgICAgIHRoaXMudXBkYXRlR3JpZEl0ZW1zU3R5bGVzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSB1cGRhdGVHcmlkSXRlbXNTdHlsZXMoKSB7XHJcbiAgICAgICAgdGhpcy5fZ3JpZEl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGdyaWRJdGVtUmVuZGVyRGF0YTogS3RkR3JpZEl0ZW1SZW5kZXJEYXRhPG51bWJlcj4gfCB1bmRlZmluZWQgPSB0aGlzLl9ncmlkSXRlbXNSZW5kZXJEYXRhW2l0ZW0uaWRdO1xyXG4gICAgICAgICAgICBpZiAoZ3JpZEl0ZW1SZW5kZXJEYXRhID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYENvdWxkblxcJ3QgZmluZCB0aGUgc3BlY2lmaWVkIGdyaWQgaXRlbSBmb3IgdGhlIGlkOiAke2l0ZW0uaWR9YCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpdGVtLnNldFN0eWxlcyhwYXJzZVJlbmRlckl0ZW1Ub1BpeGVscyhncmlkSXRlbVJlbmRlckRhdGEpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgaW5pdFN1YnNjcmlwdGlvbnMoKSB7XHJcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gW1xyXG4gICAgICAgICAgICB0aGlzLl9ncmlkSXRlbXMuY2hhbmdlcy5waXBlKFxyXG4gICAgICAgICAgICAgICAgc3RhcnRXaXRoKHRoaXMuX2dyaWRJdGVtcyksXHJcbiAgICAgICAgICAgICAgICBzd2l0Y2hNYXAoKGdyaWRJdGVtczogUXVlcnlMaXN0PEt0ZEdyaWRJdGVtQ29tcG9uZW50PikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtZXJnZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uZ3JpZEl0ZW1zLm1hcCgoZ3JpZEl0ZW0pID0+IGdyaWRJdGVtLmRyYWdTdGFydCQucGlwZShtYXAoKGV2ZW50KSA9PiAoe2V2ZW50LCBncmlkSXRlbSwgdHlwZTogJ2RyYWcnIGFzIERyYWdBY3Rpb25UeXBlfSkpKSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmdyaWRJdGVtcy5tYXAoKGdyaWRJdGVtKSA9PiBncmlkSXRlbS5yZXNpemVTdGFydCQucGlwZShtYXAoKGV2ZW50KSA9PiAoe2V2ZW50LCBncmlkSXRlbSwgdHlwZTogJ3Jlc2l6ZScgYXMgRHJhZ0FjdGlvblR5cGV9KSkpKSxcclxuICAgICAgICAgICAgICAgICAgICApLnBpcGUoZXhoYXVzdE1hcCgoe2V2ZW50LCBncmlkSXRlbSwgdHlwZX0pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW1pdCBkcmFnIG9yIHJlc2l6ZSBzdGFydCBldmVudHMuIEVuc3VyZSB0aGF0IGlzIHN0YXJ0IGV2ZW50IGlzIGluc2lkZSB0aGUgem9uZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+ICh0eXBlID09PSAnZHJhZycgPyB0aGlzLmRyYWdTdGFydGVkIDogdGhpcy5yZXNpemVTdGFydGVkKS5lbWl0KGdldERyYWdSZXNpemVFdmVudERhdGEoZ3JpZEl0ZW0sIHRoaXMubGF5b3V0KSkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGVyZm9ybSBkcmFnIHNlcXVlbmNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBlcmZvcm1EcmFnU2VxdWVuY2UkKGdyaWRJdGVtLCBldmVudCwgdHlwZSkucGlwZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcCgobGF5b3V0KSA9PiAoe2xheW91dCwgZ3JpZEl0ZW0sIHR5cGV9KSkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICApLnN1YnNjcmliZSgoe2xheW91dCwgZ3JpZEl0ZW0sIHR5cGV9KSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxheW91dCA9IGxheW91dDtcclxuICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBuZXcgcmVuZGVyaW5nIGRhdGEgZ2l2ZW4gdGhlIG5ldyBsYXlvdXQuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZVJlbmRlckRhdGEoKTtcclxuICAgICAgICAgICAgICAgIC8vIEVtaXQgZHJhZyBvciByZXNpemUgZW5kIGV2ZW50cy5cclxuICAgICAgICAgICAgICAgICh0eXBlID09PSAnZHJhZycgPyB0aGlzLmRyYWdFbmRlZCA6IHRoaXMucmVzaXplRW5kZWQpLmVtaXQoZ2V0RHJhZ1Jlc2l6ZUV2ZW50RGF0YShncmlkSXRlbSwgbGF5b3V0KSk7XHJcbiAgICAgICAgICAgICAgICAvLyBOb3RpZnkgdGhhdCB0aGUgbGF5b3V0IGhhcyBiZWVuIHVwZGF0ZWQuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmxheW91dFVwZGF0ZWQuZW1pdChsYXlvdXQpO1xyXG4gICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICBdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGVyZm9ybSBhIGdlbmVyYWwgZ3JpZCBkcmFnIGFjdGlvbiwgZnJvbSBzdGFydCB0byBlbmQuIEEgZ2VuZXJhbCBncmlkIGRyYWcgYWN0aW9uIGJhc2ljYWxseSBpbmNsdWRlcyBjcmVhdGluZyB0aGUgcGxhY2Vob2xkZXIgZWxlbWVudCBhbmQgYWRkaW5nXHJcbiAgICAgKiBzb21lIGNsYXNzIGFuaW1hdGlvbnMuIGNhbGNOZXdTdGF0ZUZ1bmMgbmVlZHMgdG8gYmUgcHJvdmlkZWQgaW4gb3JkZXIgdG8gY2FsY3VsYXRlIHRoZSBuZXcgc3RhdGUgb2YgdGhlIGxheW91dC5cclxuICAgICAqIEBwYXJhbSBncmlkSXRlbSB0aGF0IGlzIGJlZW4gZHJhZ2dlZFxyXG4gICAgICogQHBhcmFtIHBvaW50ZXJEb3duRXZlbnQgZXZlbnQgKG1vdXNlZG93biBvciB0b3VjaGRvd24pIHdoZXJlIHRoZSB1c2VyIGluaXRpYXRlZCB0aGUgZHJhZ1xyXG4gICAgICogQHBhcmFtIGNhbGNOZXdTdGF0ZUZ1bmMgZnVuY3Rpb24gdGhhdCByZXR1cm4gdGhlIG5ldyBsYXlvdXQgc3RhdGUgYW5kIHRoZSBkcmFnIGVsZW1lbnQgcG9zaXRpb25cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBwZXJmb3JtRHJhZ1NlcXVlbmNlJChncmlkSXRlbTogS3RkR3JpZEl0ZW1Db21wb25lbnQsIHBvaW50ZXJEb3duRXZlbnQ6IE1vdXNlRXZlbnQgfCBUb3VjaEV2ZW50LCB0eXBlOiBEcmFnQWN0aW9uVHlwZSk6IE9ic2VydmFibGU8S3RkR3JpZExheW91dD4ge1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IE9ic2VydmFibGU8S3RkR3JpZExheW91dD4oKG9ic2VydmVyOiBPYnNlcnZlcjxLdGRHcmlkTGF5b3V0PikgPT4ge1xyXG4gICAgICAgICAgICAvLyBSZXRyaWV2ZSBncmlkIChwYXJlbnQpIGFuZCBncmlkSXRlbSAoZHJhZ2dlZEVsZW0pIGNsaWVudCByZWN0cy5cclxuICAgICAgICAgICAgY29uc3QgZ3JpZEVsZW1DbGllbnRSZWN0OiBLdGRDbGllbnRSZWN0ID0gZ2V0TXV0YWJsZUNsaWVudFJlY3QodGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQgYXMgSFRNTEVsZW1lbnQpO1xyXG4gICAgICAgICAgICBjb25zdCBkcmFnRWxlbUNsaWVudFJlY3Q6IEt0ZENsaWVudFJlY3QgPSBnZXRNdXRhYmxlQ2xpZW50UmVjdChncmlkSXRlbS5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQgYXMgSFRNTEVsZW1lbnQpO1xyXG5cclxuICAgICAgICAgICAgY29uc3Qgc2Nyb2xsYWJsZVBhcmVudCA9IHR5cGVvZiB0aGlzLnNjcm9sbGFibGVQYXJlbnQgPT09ICdzdHJpbmcnID8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5zY3JvbGxhYmxlUGFyZW50KSA6IHRoaXMuc2Nyb2xsYWJsZVBhcmVudDtcclxuXHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3MoZ3JpZEl0ZW0uZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnbm8tdHJhbnNpdGlvbnMnKTtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyhncmlkSXRlbS5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdrdGQtZ3JpZC1pdGVtLWRyYWdnaW5nJyk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBwbGFjZWhvbGRlckNsaWVudFJlY3Q6IEt0ZENsaWVudFJlY3QgPSB7XHJcbiAgICAgICAgICAgICAgICAuLi5kcmFnRWxlbUNsaWVudFJlY3QsXHJcbiAgICAgICAgICAgICAgICBsZWZ0OiBkcmFnRWxlbUNsaWVudFJlY3QubGVmdCAtIGdyaWRFbGVtQ2xpZW50UmVjdC5sZWZ0LFxyXG4gICAgICAgICAgICAgICAgdG9wOiBkcmFnRWxlbUNsaWVudFJlY3QudG9wIC0gZ3JpZEVsZW1DbGllbnRSZWN0LnRvcFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlUGxhY2Vob2xkZXJFbGVtZW50KHBsYWNlaG9sZGVyQ2xpZW50UmVjdCwgZ3JpZEl0ZW0ucGxhY2Vob2xkZXIpO1xyXG5cclxuICAgICAgICAgICAgbGV0IG5ld0xheW91dDogS3RkR3JpZExheW91dEl0ZW1bXTtcclxuXHJcbiAgICAgICAgICAgIC8vIFRPRE8gKGVuaGFuY2VtZW50KTogY29uc2lkZXIgbW92ZSB0aGlzICdzaWRlIGVmZmVjdCcgb2JzZXJ2YWJsZSBpbnNpZGUgdGhlIG1haW4gZHJhZyBsb29wLlxyXG4gICAgICAgICAgICAvLyAgLSBQcm9zIGFyZSB0aGF0IHdlIHdvdWxkIG5vdCByZXBlYXQgc3Vic2NyaXB0aW9ucyBhbmQgdGFrZVVudGlsIHdvdWxkIHNodXQgZG93biBvYnNlcnZhYmxlcyBhdCB0aGUgc2FtZSB0aW1lLlxyXG4gICAgICAgICAgICAvLyAgLSBDb25zIGFyZSB0aGF0IG1vdmluZyB0aGlzIGZ1bmN0aW9uYWxpdHkgYXMgYSBzaWRlIGVmZmVjdCBpbnNpZGUgdGhlIG1haW4gZHJhZyBsb29wIHdvdWxkIGJlIGNvbmZ1c2luZy5cclxuICAgICAgICAgICAgY29uc3Qgc2Nyb2xsU3Vic2NyaXB0aW9uID0gdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT5cclxuICAgICAgICAgICAgICAgICghc2Nyb2xsYWJsZVBhcmVudCA/IE5FVkVSIDogdGhpcy5ncmlkU2VydmljZS5tb3VzZU9yVG91Y2hNb3ZlJChkb2N1bWVudCkucGlwZShcclxuICAgICAgICAgICAgICAgICAgICBtYXAoKGV2ZW50KSA9PiAoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyWDoga3RkUG9pbnRlckNsaWVudFgoZXZlbnQpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyWToga3RkUG9pbnRlckNsaWVudFkoZXZlbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgfSkpLFxyXG4gICAgICAgICAgICAgICAgICAgIGt0ZFNjcm9sbElmTmVhckVsZW1lbnRDbGllbnRSZWN0JChzY3JvbGxhYmxlUGFyZW50LCB7c2Nyb2xsU3RlcDogdGhpcy5zY3JvbGxTcGVlZH0pXHJcbiAgICAgICAgICAgICAgICApKS5waXBlKFxyXG4gICAgICAgICAgICAgICAgICAgIHRha2VVbnRpbChrdGRNb3VzZU9yVG91Y2hFbmQoZG9jdW1lbnQpKVxyXG4gICAgICAgICAgICAgICAgKS5zdWJzY3JpYmUoKSk7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogTWFpbiBzdWJzY3JpcHRpb24sIGl0IGxpc3RlbnMgZm9yICdwb2ludGVyIG1vdmUnIGFuZCAnc2Nyb2xsJyBldmVudHMgYW5kIHJlY2FsY3VsYXRlcyB0aGUgbGF5b3V0IG9uIGVhY2ggZW1pc3Npb25cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+XHJcbiAgICAgICAgICAgICAgICBtZXJnZShcclxuICAgICAgICAgICAgICAgICAgICBjb21iaW5lTGF0ZXN0KFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ncmlkU2VydmljZS5tb3VzZU9yVG91Y2hNb3ZlJChkb2N1bWVudCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLighc2Nyb2xsYWJsZVBhcmVudCA/IFtvZih7dG9wOiAwLCBsZWZ0OiAwfSldIDogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga3RkR2V0U2Nyb2xsVG90YWxSZWxhdGl2ZURpZmZlcmVuY2UkKHNjcm9sbGFibGVQYXJlbnQpLnBpcGUoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRXaXRoKHt0b3A6IDAsIGxlZnQ6IDB9KSAvLyBGb3JjZSBmaXJzdCBlbWlzc2lvbiB0byBhbGxvdyBDb21iaW5lTGF0ZXN0IHRvIGVtaXQgZXZlbiBubyBzY3JvbGwgZXZlbnQgaGFzIG9jY3VycmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pXHJcbiAgICAgICAgICAgICAgICAgICAgXSlcclxuICAgICAgICAgICAgICAgICkucGlwZShcclxuICAgICAgICAgICAgICAgICAgICB0YWtlVW50aWwoa3RkTW91c2VPclRvdWNoRW5kKGRvY3VtZW50KSksXHJcbiAgICAgICAgICAgICAgICApLnN1YnNjcmliZSgoW3BvaW50ZXJEcmFnRXZlbnQsIHNjcm9sbERpZmZlcmVuY2VdOiBbTW91c2VFdmVudCB8IFRvdWNoRXZlbnQsIHsgdG9wOiBudW1iZXIsIGxlZnQ6IG51bWJlciB9XSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyRHJhZ0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICogU2V0IHRoZSBuZXcgbGF5b3V0IHRvIGJlIHRoZSBsYXlvdXQgaW4gd2hpY2ggdGhlIGNhbGNOZXdTdGF0ZUZ1bmMgd291bGQgYmUgZXhlY3V0ZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIE5PVEU6IHVzaW5nIHRoZSBtdXRhdGVkIGxheW91dCBpcyB0aGUgd2F5IHRvIGdvIGJ5ICdyZWFjdC1ncmlkLWxheW91dCcgdXRpbHMuIElmIHdlIGRvbid0IHVzZSB0aGUgcHJldmlvdXMgbGF5b3V0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBzb21lIHV0aWxpdGllcyBmcm9tICdyZWFjdC1ncmlkLWxheW91dCcgd291bGQgbm90IHdvcmsgYXMgZXhwZWN0ZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50TGF5b3V0OiBLdGRHcmlkTGF5b3V0ID0gbmV3TGF5b3V0IHx8IHRoaXMubGF5b3V0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBjb3JyZWN0IG5ld1N0YXRlRnVuYyBkZXBlbmRpbmcgb24gaWYgd2UgYXJlIGRyYWdnaW5nIG9yIHJlc2l6aW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbGNOZXdTdGF0ZUZ1bmMgPSB0eXBlID09PSAnZHJhZycgPyBrdGRHcmlkSXRlbURyYWdnaW5nIDoga3RkR3JpZEl0ZW1SZXNpemluZztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHtsYXlvdXQsIGRyYWdnZWRJdGVtUG9zfSA9IGNhbGNOZXdTdGF0ZUZ1bmMoZ3JpZEl0ZW0sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dDogY3VycmVudExheW91dCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvd0hlaWdodDogdGhpcy5yb3dIZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sczogdGhpcy5jb2xzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmVudENvbGxpc2lvbjogdGhpcy5wcmV2ZW50Q29sbGlzaW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2FwOiB0aGlzLmdhcCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5jb21wYWN0VHlwZSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlckRvd25FdmVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ZXJEcmFnRXZlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmlkRWxlbUNsaWVudFJlY3QsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcmFnRWxlbUNsaWVudFJlY3QsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxEaWZmZXJlbmNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdMYXlvdXQgPSBsYXlvdXQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdyaWRDdXJyZW50SGVpZ2h0ID0gdGhpcy5oZWlnaHQgPz8gKHRoaXMucm93SGVpZ2h0ID09PSAnZml0JyA/IGdyaWRFbGVtQ2xpZW50UmVjdC5oZWlnaHQgOiBnZXRHcmlkSGVpZ2h0KG5ld0xheW91dCwgdGhpcy5yb3dIZWlnaHQsIHRoaXMuZ2FwKSlcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2dyaWRJdGVtc1JlbmRlckRhdGEgPSBsYXlvdXRUb1JlbmRlckl0ZW1zKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHM6IHRoaXMuY29scyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvd0hlaWdodDogdGhpcy5yb3dIZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF5b3V0OiBuZXdMYXlvdXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2ZW50Q29sbGlzaW9uOiB0aGlzLnByZXZlbnRDb2xsaXNpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnYXA6IHRoaXMuZ2FwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBncmlkRWxlbUNsaWVudFJlY3Qud2lkdGgsIGdyaWRFbGVtQ2xpZW50UmVjdC5oZWlnaHQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3R3JpZEl0ZW1SZW5kZXJEYXRhID0gey4uLnRoaXMuX2dyaWRJdGVtc1JlbmRlckRhdGFbZ3JpZEl0ZW0uaWRdfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwbGFjZWhvbGRlclN0eWxlcyA9IHBhcnNlUmVuZGVySXRlbVRvUGl4ZWxzKG5ld0dyaWRJdGVtUmVuZGVyRGF0YSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQdXQgdGhlIHJlYWwgZmluYWwgcG9zaXRpb24gdG8gdGhlIHBsYWNlaG9sZGVyIGVsZW1lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbGFjZWhvbGRlciEuc3R5bGUud2lkdGggPSBwbGFjZWhvbGRlclN0eWxlcy53aWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbGFjZWhvbGRlciEuc3R5bGUuaGVpZ2h0ID0gcGxhY2Vob2xkZXJTdHlsZXMuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsYWNlaG9sZGVyIS5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlWCgke3BsYWNlaG9sZGVyU3R5bGVzLmxlZnR9KSB0cmFuc2xhdGVZKCR7cGxhY2Vob2xkZXJTdHlsZXMudG9wfSlgO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbW9kaWZ5IHRoZSBwb3NpdGlvbiBvZiB0aGUgZHJhZ2dlZCBpdGVtIHRvIGJlIHRoZSBvbmNlIHdlIHdhbnQgKGZvciBleGFtcGxlIHRoZSBtb3VzZSBwb3NpdGlvbiBvciB3aGF0ZXZlcilcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ3JpZEl0ZW1zUmVuZGVyRGF0YVtncmlkSXRlbS5pZF0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5kcmFnZ2VkSXRlbVBvcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiB0aGlzLl9ncmlkSXRlbXNSZW5kZXJEYXRhW2dyaWRJdGVtLmlkXS5pZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGFyZSBwZXJmb3JtaW5nIGEgcmVzaXplLCBhbmQgYm91bmRzIGhhdmUgY2hhbmdlZCwgZW1pdCBldmVudC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogT25seSBlbWl0IG9uIHJlc2l6ZSBmb3Igbm93LiBVc2UgY2FzZSBmb3Igbm9ybWFsIGRyYWcgaXMgbm90IGp1c3RpZmllZCBmb3Igbm93LiBFbWl0dGluZyBvbiByZXNpemUgaXMsIHNpbmNlIHdlIG1heSB3YW50IHRvIHJlLXJlbmRlciB0aGUgZ3JpZCBpdGVtIG9yIHRoZSBwbGFjZWhvbGRlciBpbiBvcmRlciB0byBmaXQgdGhlIG5ldyBib3VuZHMuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAncmVzaXplJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldkdyaWRJdGVtID0gY3VycmVudExheW91dC5maW5kKGl0ZW0gPT4gaXRlbS5pZCA9PT0gZ3JpZEl0ZW0uaWQpITtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0dyaWRJdGVtID0gbmV3TGF5b3V0LmZpbmQoaXRlbSA9PiBpdGVtLmlkID09PSBncmlkSXRlbS5pZCkhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaXRlbSByZXNpemVkIGhhcyBjaGFuZ2VkLCBpZiBzbywgZW1pdCByZXNpemUgY2hhbmdlIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWt0ZEdyaWRJdGVtTGF5b3V0SXRlbUFyZUVxdWFsKHByZXZHcmlkSXRlbSwgbmV3R3JpZEl0ZW0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ncmlkSXRlbVJlc2l6ZS5lbWl0KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IG5ld0dyaWRJdGVtUmVuZGVyRGF0YS53aWR0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBuZXdHcmlkSXRlbVJlbmRlckRhdGEuaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmlkSXRlbVJlZjogZ2V0RHJhZ1Jlc2l6ZUV2ZW50RGF0YShncmlkSXRlbSwgbmV3TGF5b3V0KS5ncmlkSXRlbVJlZlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAoZXJyb3IpID0+IG9ic2VydmVyLmVycm9yKGVycm9yKSxcclxuICAgICAgICAgICAgICAgICAgICAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgZHJhZyBjbGFzc2VzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKGdyaWRJdGVtLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ25vLXRyYW5zaXRpb25zJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKGdyaWRJdGVtLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2t0ZC1ncmlkLWl0ZW0tZHJhZ2dpbmcnKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlc3Ryb3lQbGFjZWhvbGRlcigpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdMYXlvdXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBuZXdMYXlvdXQgc2hvdWxkIGFscmVhZHkgYmUgcHJ1bmVkLiBJZiBub3QsIGl0IHNob3VsZCBoYXZlIHR5cGUgTGF5b3V0LCBub3QgS3RkR3JpZExheW91dCBhcyBpdCBpcyBub3cuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJ1bmUgcmVhY3QtZ3JpZC1sYXlvdXQgY29tcGFjdCBleHRyYSBwcm9wZXJ0aWVzLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLm5leHQobmV3TGF5b3V0Lm1hcChpdGVtID0+ICh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpdGVtLmlkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBpdGVtLngsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IGl0ZW0ueSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdzogaXRlbS53LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoOiBpdGVtLmgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pblc6IGl0ZW0ubWluVyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluSDogaXRlbS5taW5ILFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhXOiBpdGVtLm1heFcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heEg6IGl0ZW0ubWF4SCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkgYXMgS3RkR3JpZExheW91dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IE5lZWQgd2UgcmVhbGx5IHRvIGVtaXQgaWYgdGhlcmUgaXMgbm8gbGF5b3V0IGNoYW5nZSBidXQgZHJhZyBzdGFydGVkIGFuZCBlbmRlZD9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KHRoaXMubGF5b3V0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG5cclxuXHJcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBzY3JvbGxTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcclxuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBDcmVhdGVzIHBsYWNlaG9sZGVyIGVsZW1lbnQgKi9cclxuICAgIHByaXZhdGUgY3JlYXRlUGxhY2Vob2xkZXJFbGVtZW50KGNsaWVudFJlY3Q6IEt0ZENsaWVudFJlY3QsIGdyaWRJdGVtUGxhY2Vob2xkZXI/OiBLdGRHcmlkSXRlbVBsYWNlaG9sZGVyKSB7XHJcbiAgICAgICAgdGhpcy5wbGFjZWhvbGRlciA9IHRoaXMucmVuZGVyZXIuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgdGhpcy5wbGFjZWhvbGRlciEuc3R5bGUud2lkdGggPSBgJHtjbGllbnRSZWN0LndpZHRofXB4YDtcclxuICAgICAgICB0aGlzLnBsYWNlaG9sZGVyIS5zdHlsZS5oZWlnaHQgPSBgJHtjbGllbnRSZWN0LmhlaWdodH1weGA7XHJcbiAgICAgICAgdGhpcy5wbGFjZWhvbGRlciEuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZVgoJHtjbGllbnRSZWN0LmxlZnR9cHgpIHRyYW5zbGF0ZVkoJHtjbGllbnRSZWN0LnRvcH1weClgO1xyXG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXIhLmNsYXNzTGlzdC5hZGQoJ2t0ZC1ncmlkLWl0ZW0tcGxhY2Vob2xkZXInKTtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyLmFwcGVuZENoaWxkKHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCB0aGlzLnBsYWNlaG9sZGVyKTtcclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIGFuZCBhcHBlbmQgY3VzdG9tIHBsYWNlaG9sZGVyIGlmIHByb3ZpZGVkLlxyXG4gICAgICAgIC8vIEltcG9ydGFudDogQXBwZW5kIGl0IGFmdGVyIGNyZWF0aW5nICYgYXBwZW5kaW5nIHRoZSBjb250YWluZXIgcGxhY2Vob2xkZXIuIFRoaXMgd2F5IHdlIGVuc3VyZSBwYXJlbnQgYm91bmRzIGFyZSBzZXQgd2hlbiBjcmVhdGluZyB0aGUgZW1iZWRkZWRWaWV3LlxyXG4gICAgICAgIGlmIChncmlkSXRlbVBsYWNlaG9sZGVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGxhY2Vob2xkZXJSZWYgPSB0aGlzLnZpZXdDb250YWluZXJSZWYuY3JlYXRlRW1iZWRkZWRWaWV3KFxyXG4gICAgICAgICAgICAgICAgZ3JpZEl0ZW1QbGFjZWhvbGRlci50ZW1wbGF0ZVJlZixcclxuICAgICAgICAgICAgICAgIGdyaWRJdGVtUGxhY2Vob2xkZXIuZGF0YVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB0aGlzLnBsYWNlaG9sZGVyUmVmLnJvb3ROb2Rlcy5mb3JFYWNoKG5vZGUgPT4gdGhpcy5wbGFjZWhvbGRlciEuYXBwZW5kQ2hpbGQobm9kZSkpO1xyXG4gICAgICAgICAgICB0aGlzLnBsYWNlaG9sZGVyUmVmLmRldGVjdENoYW5nZXMoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnBsYWNlaG9sZGVyIS5jbGFzc0xpc3QuYWRkKCdrdGQtZ3JpZC1pdGVtLXBsYWNlaG9sZGVyLWRlZmF1bHQnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIERlc3Ryb3lzIHRoZSBwbGFjZWhvbGRlciBlbGVtZW50IGFuZCBpdHMgVmlld1JlZi4gKi9cclxuICAgIHByaXZhdGUgZGVzdHJveVBsYWNlaG9sZGVyKCkge1xyXG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXI/LnJlbW92ZSgpO1xyXG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXJSZWY/LmRlc3Ryb3koKTtcclxuICAgICAgICB0aGlzLnBsYWNlaG9sZGVyID0gdGhpcy5wbGFjZWhvbGRlclJlZiA9IG51bGwhO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9jb2xzOiBOdW1iZXJJbnB1dDtcclxuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9yb3dIZWlnaHQ6IE51bWJlcklucHV0O1xyXG4gICAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX3Njcm9sbFNwZWVkOiBOdW1iZXJJbnB1dDtcclxuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9jb21wYWN0T25Qcm9wc0NoYW5nZTogQm9vbGVhbklucHV0O1xyXG4gICAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX3ByZXZlbnRDb2xsaXNpb246IEJvb2xlYW5JbnB1dDtcclxufVxyXG5cclxuIiwiPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PiJdfQ==